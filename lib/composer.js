// Generated by CoffeeScript 1.10.0
(function() {
  var Terphite, _, blessed, contrib, k, path, ref, request, v,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  blessed = require('blessed');

  contrib = require('blessed-contrib');

  request = require('request');

  path = require('path');

  _ = require('lodash');

  ref = require('./helpers');
  for (k in ref) {
    v = ref[k];
    global[k] = v;
  }

  module.exports = Terphite = (function() {
    function Terphite(graphite_uri1) {
      this.graphite_uri = graphite_uri1;
    }

    Terphite.prototype.composer = function() {
      var autorefresh, autorefresh_loop, autorefresh_time, fetchMetricData, functions_tree, graphite_uri, help, help_content, layout, line, loadMetricsTree, max_data_points, metricURI, metrics_popup, screen, selected_metrics, setStatus, status, statusString, target_popup, time_from, time_popup, toggleAutorefresh, tree;
      selected_metrics = [];
      time_from = '-1min';
      autorefresh_time = 10;
      max_data_points = 300;
      graphite_uri = this.graphite_uri;
      autorefresh = 0;
      screen = blessed.screen({
        smartCSR: true,
        debug: true,
        title: 'Graphite Browser',
        warnings: true,
        dockBorders: true,
        ignoreDockContrast: true
      });
      layout = blessed.layout({
        parent: screen,
        width: '100%',
        height: '100%',
        border: 'line',
        layout: 'grid',
        style: {
          bg: 'black',
          border: {
            fg: 'blue'
          }
        }
      });
      tree = contrib.tree({
        parent: layout,
        top: 0,
        left: 0,
        padding: 1,
        width: '25%+1',
        height: '80%-2',
        template: {
          lines: true
        }
      });
      functions_tree = contrib.tree({
        parent: screen,
        top: 'center',
        left: 'center',
        padding: 1,
        width: '80%',
        height: '50%',
        hidden: true,
        template: {
          lines: true
        }
      });
      statusString = function() {
        return ["from: " + time_from, "autorefresh: " + (!autorefresh ? 'off' : autorefresh + 's'), "maxdatapoints: " + (!max_data_points ? 'unlimited' : max_data_points)].join('  ');
      };
      setStatus = function() {
        return status.setContent(statusString());
      };
      status = blessed.box({
        parent: layout,
        top: 0,
        left: 0,
        height: 3,
        width: '100%',
        content: statusString(),
        border: {
          type: 'line',
          fg: 'blue'
        }
      });
      screen.append(status);
      help_content = '  [ decrease time 1min, { decrease time 1s\n';
      help_content += '  ] increase time 1min, } increase time 1s\n';
      help_content += '  t set relative "from" time, m metrics list popup, i set autorefresh interval\n';
      help_content += '  a autorefresh toggle, x set max datapoints\n';
      help_content += '  o open in browser, c copy graphite URI to clipboard (iTerm2 only)\n';
      help_content += 'Metrics List Keys:\n';
      help_content += '  C-a append new target, C-d delete selected, <enter> edit selected\n';
      help = blessed.box({
        parent: layout,
        top: '80%-1',
        left: 0,
        height: '20%+2',
        content: help_content,
        border: {
          type: 'line',
          fg: 'blue'
        }
      });
      screen.append(help);
      line = contrib.line({
        parent: layout,
        left: '25%',
        top: 2,
        height: '80%-2',
        width: '75%+1',
        showLegend: true,
        legend: {
          width: 60
        },
        border: {
          type: 'line',
          fg: 'blue'
        }
      });
      screen.append(line);
      time_popup = blessed.prompt({
        parent: layout,
        left: 'center',
        top: 'center',
        width: '80%',
        height: 8,
        keys: true,
        mouse: true,
        style: {
          fg: 'blue'
        },
        border: {
          type: 'line',
          fg: 'gray'
        }
      });
      screen.append(time_popup);
      metrics_popup = blessed.list({
        parent: layout,
        hidden: true,
        left: 'center',
        top: 'center',
        width: '90%',
        height: 'half',
        padding: 1,
        interactive: true,
        items: selected_metrics,
        mouse: true,
        keys: true,
        tags: true,
        style: {
          bg: 'blue'
        },
        border: {
          type: 'line',
          fg: 'gray'
        }
      });
      screen.append(metrics_popup);
      target_popup = blessed.prompt({
        parent: layout,
        left: 'center',
        top: 'center',
        width: '80%',
        height: 8,
        mouse: true,
        keys: true,
        style: {
          fg: 'blue'
        },
        border: {
          type: 'line',
          fg: 'gray'
        }
      });
      screen.append(target_popup);
      loadMetricsTree = function() {
        var createObject, options;
        options = {
          uri: graphite_uri + "/metrics/index.json",
          json: true
        };
        request(options, function(err, resp, body) {
          var j, len, metric, metrics, obj;
          metrics = {};
          for (j = 0, len = body.length; j < len; j++) {
            metric = body[j];
            obj = createObject(metric);
            _.merge(metrics, obj);
          }
          tree.setData({
            extended: true,
            name: 'metrics',
            path: 'metrics',
            children: metrics
          });
          return screen.render();
        });
        return createObject = function(key, original_key) {
          var obj, original_parts, parts, remainingParts;
          if (original_key == null) {
            original_key = '';
          }
          obj = {};
          parts = key.split('.');
          if (original_key === '') {
            original_key = key;
          }
          original_parts = original_key.split('.');
          path = original_parts.slice(0, +(original_parts.length - parts.length) + 1 || 9e9).join('.');
          if (parts.length === 1) {
            obj[parts[0]] = {
              name: parts[0],
              extended: false,
              path: path,
              leaf: true
            };
          } else if (parts.length > 1) {
            remainingParts = parts.slice(1, parts.length).join('.');
            obj[parts[0]] = {
              name: parts[0],
              extended: false,
              path: path,
              leaf: false,
              children: createObject(remainingParts, original_key)
            };
          }
          return obj;
        };
      };
      metricURI = function(metrics, from, params, opts) {
        var extra, maxdp, target;
        if (params == null) {
          params = {};
        }
        if (opts == null) {
          opts = {
            format: 'json'
          };
        }
        extra = '';
        if (opts.format === 'json') {
          extra += '&format=json';
        }
        maxdp = parseInt(opts.maxDataPoints, 10);
        if (maxdp > 0) {
          extra += "&maxDataPoints=" + maxdp;
        }
        target = metrics.join('&target=');
        return graphite_uri + "/render?from=" + from + "&target=" + target + extra;
      };
      fetchMetricData = function(metrics, from) {
        var options;
        options = {
          uri: metricURI(metrics, from, {}, {
            format: 'json',
            maxDataPoints: max_data_points
          }),
          json: true
        };
        return request(options, function(err, resp, body) {
          var i, point, series, target, ts;
          series = (function() {
            var j, len, results;
            results = [];
            for (i = j = 0, len = body.length; j < len; i = ++j) {
              target = body[i];
              results.push({
                title: target.target || '[unnamed_target]',
                y: (function() {
                  var l, len1, ref1, results1;
                  ref1 = target.datapoints;
                  results1 = [];
                  for (l = 0, len1 = ref1.length; l < len1; l++) {
                    point = ref1[l];
                    results1.push(point[0]);
                  }
                  return results1;
                })(),
                x: (function() {
                  var l, len1, ref1, results1;
                  ref1 = target.datapoints;
                  results1 = [];
                  for (l = 0, len1 = ref1.length; l < len1; l++) {
                    point = ref1[l];
                    ts = new Date(point[1] * 1000);
                    results1.push((ts.getHours()) + ":" + (format_twodigit(ts.getUTCMinutes())));
                  }
                  return results1;
                })(),
                style: {
                  line: colors[i % 15]
                }
              });
            }
            return results;
          })();
          if (series.length === 0) {
            series = [
              {
                title: 'no data',
                x: [],
                y: []
              }
            ];
          }
          line.setData(series);
          return screen.render();
        });
      };
      tree.on('select', function(node) {
        path = node.path;
        if (indexOf.call(selected_metrics, path) >= 0) {
          selected_metrics = selected_metrics.filter(function(metric) {
            return metric !== path;
          });
        } else if (node.leaf) {
          selected_metrics.push(path);
        }
        return fetchMetricData(selected_metrics, time_from);
      });
      screen.key(['['], function(ch, key) {
        var t;
        t = (parse_time_to_i(time_from)) - MIN;
        time_from = t < MIN ? '-1min' : seconds_to_time_string(t);
        setStatus();
        return fetchMetricData(selected_metrics, time_from);
      });
      screen.key([']'], function(ch, key) {
        var t;
        t = (parse_time_to_i(time_from)) + MIN;
        time_from = seconds_to_time_string(t);
        setStatus();
        return fetchMetricData(selected_metrics, time_from);
      });
      screen.key(['{'], function(ch, key) {
        var t;
        t = (parse_time_to_i(time_from)) - H;
        time_from = t < H ? '-1h' : seconds_to_time_string(t);
        setStatus();
        return fetchMetricData(selected_metrics, time_from);
      });
      screen.key(['}'], function(ch, key) {
        var t;
        t = (parse_time_to_i(time_from)) + H;
        time_from = seconds_to_time_string(t);
        setStatus();
        return fetchMetricData(selected_metrics, time_from);
      });
      screen.key(['t'], function(ch, key) {
        return time_popup.input('set relative _from_ time (y, mon, w, d, h, min, s)\n  eg: -1d12h', time_from, function(err, value) {
          var d, h, min, mon, ref1, s, w, y;
          ref1 = parse_time(value), y = ref1[0], mon = ref1[1], w = ref1[2], d = ref1[3], h = ref1[4], min = ref1[5], s = ref1[6];
          time_from = get_time_string(y, mon, w, d, h, min, s);
          setStatus();
          return fetchMetricData(selected_metrics, time_from);
        });
      });
      screen.key(['m'], function(ch, key) {
        metrics_popup.setItems(selected_metrics);
        metrics_popup.focus();
        metrics_popup.show();
        return screen.render();
      });
      metrics_popup.on('select', function(item, select) {
        return target_popup.input('Edit target', item.getText(), function(err, value) {
          selected_metrics[select] = value;
          metrics_popup.setItems(selected_metrics);
          return screen.render();
        });
      });
      metrics_popup.key('C-d', function(ch, key) {
        selected_metrics.splice(metrics_popup.selected, 1);
        metrics_popup.setItems(selected_metrics);
        return fetchMetricData(selected_metrics, time_from);
      });
      metrics_popup.key('C-a', function(ch, key) {
        return target_popup.input('Add target', '', function(err, value) {
          selected_metrics.push(value);
          metrics_popup.setItems(selected_metrics);
          return fetchMetricData(selected_metrics, time_from);
        });
      });
      metrics_popup.key(['escape'], function(ch, key) {
        metrics_popup.hide();
        tree.focus();
        return fetchMetricData(selected_metrics, time_from);
      });
      screen.key(['c'], function(ch, key) {
        screen.cursorReset();
        screen.copyToClipboard(metricURI(selected_metrics, time_from, {}, {}));
        screen.realloc();
        return screen.render();
      });
      screen.key(['o'], function(ch, key) {
        return screen.exec('open', [metricURI(selected_metrics, time_from, {}, {})]);
      });
      autorefresh_loop = null;
      toggleAutorefresh = function() {
        if (!autorefresh) {
          autorefresh = autorefresh_time;
          setStatus();
          screen.render();
          return autorefresh_loop = setInterval(function() {
            return fetchMetricData(selected_metrics, time_from);
          }, autorefresh * 1000);
        } else {
          autorefresh = 0;
          clearInterval(autorefresh_loop);
          setStatus();
          screen.render();
          return autorefresh_loop = null;
        }
      };
      screen.key(['a'], function(ch, key) {
        return toggleAutorefresh();
      });
      screen.key(['i'], function(ch, key) {
        return time_popup.input('set autorefresh interval time (seconds)', autorefresh_time.toString(), function(e, v) {
          var t;
          t = parseInt(v);
          autorefresh_time = t > 0 ? t : 1;
          if (autorefresh) {
            clearInterval(autorefresh_loop);
          }
          autorefresh = autorefresh_time;
          setStatus();
          screen.render();
          return autorefresh_loop = setInterval(function() {
            return fetchMetricData(selected_metrics, time_from);
          }, autorefresh * 1000);
        });
      });
      screen.key(['x'], function(ch, key) {
        return time_popup.input('set max datapoints for graphite api to return in json response\n  0 = unlimited', max_data_points.toString(), function(e, v) {
          var p;
          p = parseInt(v);
          max_data_points = p < 0 ? 0 : p;
          setStatus();
          return fetchMetricData(selected_metrics, time_from);
        });
      });
      screen.key(['q', 'C-c'], function(ch, key) {
        return process.exit(0);
      });
      tree.focus();
      loadMetricsTree();
      return fetchMetricData(selected_metrics, time_from);
    };

    return Terphite;

  })();

}).call(this);
